from unittest import mock

from begin.registry import (
    Target,
    TargetMetaData,
)


class TestTargetMetaData:

    def test_init(self, make_random_string):
        dummy_function_name = make_random_string()
        dummy_registry_namespace = make_random_string()

        metadata = TargetMetaData(
            function_name=dummy_function_name,
            registry_namespace=dummy_registry_namespace,
        )
        assert metadata.function_name == dummy_function_name
        assert metadata.registry_namespace == dummy_registry_namespace
        assert metadata.__dataclass_params__.frozen

    def test_required_autogenerated_methods(self, make_random_string):
        # Note: this tests a few auto-generated methods on the TargetMetaData.
        # This is not intended to test the dataclasses library, but these auto-methods
        # can be switched off, and this is to ensure that they aren't.
        dummy_function_name = make_random_string()
        dummy_registry_namespace = make_random_string()

        metadata_instances = [
            TargetMetaData(function_name=dummy_function_name, registry_namespace=dummy_registry_namespace)
            for _ in range(10)
        ]

        # All instances should be equal
        assert all(instance == metadata_instances[0] for instance in metadata_instances)

        # All instances should hash to the same value
        assert all(hash(instance) == hash(metadata_instances[0]) for instance in metadata_instances)

    def test_from_target_function(self, make_random_string):
        # Tests the TargetMetaData.from_target_function factory to ensure instances
        # are correctly generated using the function name (and registry_namespace)
        dummy_registry_namespace = make_random_string()

        metadata = TargetMetaData.from_target_function(
            function=lambda: ...,
            registry_namespace=dummy_registry_namespace,
        )

        assert metadata.function_name == '<lambda>'
        assert metadata.registry_namespace is dummy_registry_namespace

    def test_from_target_name(self, make_random_string):
        dummy_function_name = make_random_string()
        dummy_registry_namespace = make_random_string()

        metadata = TargetMetaData.from_target_name(
            name=dummy_function_name,
            registry_namespace=dummy_registry_namespace,
        )

        assert metadata.function_name == dummy_function_name
        assert metadata.registry_namespace == dummy_registry_namespace


class TestTarget:

    @mock.patch('begin.registry.TargetMetaData')
    def test_initialisation(self, MockTargetMetaData):
        stub_function = lambda: ...
        stub_namespace = 'namespace'
        target = Target(function=stub_function, registry_namespace=stub_namespace)

        # target._function assigned correctly
        assert target._function is stub_function

        # target._registry_namespace assigned correctly
        assert target._registry_namespace is stub_namespace

        # target._metadata assigned correctly...
        assert target._metadata is MockTargetMetaData.from_target_function.return_value

        # ... and the value was created correctly
        assert MockTargetMetaData.from_target_function.call_args_list == [
            mock.call(
                function=stub_function,
                registry_namespace=stub_namespace,
            ),
        ]

    @mock.patch('begin.registry.TargetMetaData')
    def test_key(self, MockTargetMetaData):
        target = Target(
            function=lambda: ...,
            registry_namespace='namespace',
        )
        mock_metadata = MockTargetMetaData.from_target_function.return_value
        assert target.key is mock_metadata

    @mock.patch('begin.registry.TargetMetaData')
    def test_registry_namespace(self, MockTargetMetaData):
        target = Target(
            function=lambda: ...,
            registry_namespace='namespace',
        )
        metadata = MockTargetMetaData.from_target_function.return_value
        registry_namespace = target.registry_namespace
        assert metadata.registry_namespace is registry_namespace

    @mock.patch('begin.registry.TargetMetaData')
    def test_function_name(self, MockTargetMetaData):
        target = Target(
            function=lambda: ...,
            registry_namespace='namespace',
        )
        metadata = MockTargetMetaData.from_target_function.return_value
        function_name = target.function_name
        assert metadata.function_name is function_name

    def test_execute(self):
        mock_function = mock.Mock()
        mock_function.__name__ = 'mock_function'
        mock_target = Target(
            function=mock_function,
            registry_namespace='namespace',
        )
        return_value = mock_target.execute()

        # Target.execute should defer to Target._function
        assert mock_function.call_args_list == [mock.call()]

        # Target.execute should return None
        assert return_value is None


class TestRegistry:
    pass
